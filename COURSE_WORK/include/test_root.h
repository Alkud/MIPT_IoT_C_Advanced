#ifndef TEST_ROOT_H
#define TEST_ROOT_H

#include "types.h"

/**
 * Комбинации функций для поиска пересечений
 */
static const int root_function_indices[6][2] = {
    {1, 3},
    {1, 0},
    {2, 3},
    {1, 3},
    {2, 0},
    {2, 3}
};

/**
*   Интервалы поиска пересечений функций
*/
static const Interval root_intervals[] = {
    {-6.0, -5.0},
    {-6.0, -4.0},
    {-1.0, -0.01},
    {0.01, 1.0},
    {2.0, 4.0},
    {2.0, 4.0}
};

/**
* Точки пересечения функций, найденные методом Брента через scipy
*/
static const Point brent_roots[] = {
    // пересечение функций f1 и f3
    {-5.854101966249685, 1.1102230246251565e-16},
    // пересечение функции f1 и оси X
    {-5.0, 0.0},
    // пересечение функций f2 и f3
    {-0.2439288539037136, 1.7763568394002505e-15},
    // пересечение функций f1 и f3
    {0.8541019662498792, 9.174883075502294e-13},
    // пересечение функции f2 и оси X
    {3.0, 0.0},
    // пересечение функций f2 и f3
    {3.2439288539037134, -7.771561172376096e-16}
};

/**
 * Тест метода деления отрезка пополам
* @param func_idx_1 индекс 1-ой функции в списке тестируемых
 * @param func_idx_2 индекс 2-ой функции в списке тестируемых
 * @param a левая граница интервала поиска
 * @param b правая граница итервала поиска
 * @param eps точность
 * @param true_value истинное значение корня
 *
 * @returns 0 в случае успеха, -1 иначе
 *  */
int test_root(int func_idx_1, int func_idx_2, double a, double b, double eps, double true_value);

/**
 * Полный тест алгоритма поиска корня функции на отрезке
 * @return 1 если все тесты пройдены, 0 иначе
 */
int root_algo_tests(void);

#endif //TEST_ROOT_H
